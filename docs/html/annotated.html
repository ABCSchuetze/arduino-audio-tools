<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>arduino-audio-tools: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">arduino-audio-tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class List</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_0_" class="arrow" onclick="toggleFolder('0_')">&#9660;</span><span class="icona"><span class="icon">N</span></span><b>audio_tools</b></td><td class="desc"></td></tr>
<tr id="row_0_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_a2_d_p_stream.html" target="_self">A2DPStream</a></td><td class="desc"><a class="el" href="class_stream.html">Stream</a> support for A2DP: begin(TX_MODE) uses a2dp_source - begin(RX_MODE) a a2dp_sink The data is in int16_t with 2 channels at 44100 hertz </td></tr>
<tr id="row_0_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_a_a_c_decoder.html" target="_self">AACDecoder</a></td><td class="desc">Audio Decoder which decodes AAC into a PCM stream </td></tr>
<tr id="row_0_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_a_a_c_encoder.html" target="_self">AACEncoder</a></td><td class="desc">Encodes PCM data to the AAC format and writes the result to a stream </td></tr>
<tr id="row_0_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_analog_audio.html" target="_self">AnalogAudio</a></td><td class="desc">A very fast ADC and DAC using the ESP32 <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> interface </td></tr>
<tr id="row_0_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_analog_audio_stream.html" target="_self">AnalogAudioStream</a></td><td class="desc">We support the <a class="el" href="class_stream.html">Stream</a> interface for the ADC class </td></tr>
<tr id="row_0_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_analog_config.html" target="_self">AnalogConfig</a></td><td class="desc">ESP32 specific configuration for i2s input via adc. The default input pin is GPIO34. We always use int16_t values on 2 channels </td></tr>
<tr id="row_0_6_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_audio_base_info.html" target="_self">AudioBaseInfo</a></td><td class="desc">Basic Audio information which drives e.g. <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> </td></tr>
<tr id="row_0_7_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_base_info_dependent.html" target="_self">AudioBaseInfoDependent</a></td><td class="desc">Supports changes to the sampling rate, bits and channels </td></tr>
<tr id="row_0_8_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_logger.html" target="_self">AudioLogger</a></td><td class="desc">A simple Logger that writes messages dependent on the log level </td></tr>
<tr id="row_0_9_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_output_stream.html" target="_self">AudioOutputStream</a></td><td class="desc">Construct a new Encoded <a class="el" href="class_stream.html">Stream</a> object which is supporting defined Audio File types </td></tr>
<tr id="row_0_10_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_output_with_callback.html" target="_self">AudioOutputWithCallback</a></td><td class="desc">ESP8266Audio AudioOutput class which stores the data in a temporary buffer. The buffer can be consumed e.g. by a callback function by calling <a class="el" href="classaudio__tools_1_1_buffered_stream.html#a057be5d11995e5454884913f39870a8b" title="reads a byte - to be avoided">read()</a>; </td></tr>
<tr id="row_0_11_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_server.html" target="_self">AudioServer</a></td><td class="desc">A simple Arduino Webserver which streams the result This class is based on the WiFiServer class. All you need to do is to provide the data with a callback method or from an Arduino <a class="el" href="class_stream.html">Stream</a> </td></tr>
<tr id="row_0_12_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_u_s_b.html" target="_self">AudioUSB</a></td><td class="desc"></td></tr>
<tr id="row_0_13_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_w_a_v_server.html" target="_self">AudioWAVServer</a></td><td class="desc">A simple Arduino Webserver which streams the audio PCM data result as WAV file. This class is based on the WiFiServer class. All you need to do is to provide the data with a callback method or from a <a class="el" href="class_stream.html">Stream</a> </td></tr>
<tr id="row_0_14_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_audio_writer.html" target="_self">AudioWriter</a></td><td class="desc">E.g. used by Encoders and Decoders </td></tr>
<tr id="row_0_15_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_base_buffer.html" target="_self">BaseBuffer</a></td><td class="desc">Shared functionality of all buffers </td></tr>
<tr id="row_0_16_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_base_converter.html" target="_self">BaseConverter</a></td><td class="desc">Abstract Base class for Converters A converter is processing the data in the indicated array </td></tr>
<tr id="row_0_17_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_buffered_stream.html" target="_self">BufferedStream</a></td><td class="desc">The Arduino <a class="el" href="class_stream.html">Stream</a> supports operations on single characters. This is usually not the best way to push audio information, but we will support it anyway - by using a buffer. On reads: if the buffer is empty it gets refilled - for writes if it is full it gets flushed </td></tr>
<tr id="row_0_18_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_callback_converter.html" target="_self">CallbackConverter</a></td><td class="desc">Converts e.g. 24bit data to the indicated bigger data type </td></tr>
<tr id="row_0_19_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_callback_stream.html" target="_self">CallbackStream</a></td><td class="desc">AudioOutput class which stores the data in a temporary buffer. The buffer can be consumed e.g. by a callback function by calling <a class="el" href="classaudio__tools_1_1_buffered_stream.html#a057be5d11995e5454884913f39870a8b" title="reads a byte - to be avoided">read()</a>; </td></tr>
<tr id="row_0_20_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_channel_converter.html" target="_self">ChannelConverter</a></td><td class="desc">Covnerts the data from T src[][2] to a Channels array </td></tr>
<tr id="row_0_21_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_converter_auto_center.html" target="_self">ConverterAutoCenter</a></td><td class="desc">Makes sure that the avg of the signal is set to 0 </td></tr>
<tr id="row_0_22_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_converter_fill_left_and_right.html" target="_self">ConverterFillLeftAndRight</a></td><td class="desc">Make sure that both channels contain any data </td></tr>
<tr id="row_0_23_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_converter_scaler.html" target="_self">ConverterScaler</a></td><td class="desc">Multiplies the values with the indicated factor adds the offset and clips at maxValue. To mute use a factor of 0.0! </td></tr>
<tr id="row_0_24_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_converter_switch_left_and_right.html" target="_self">ConverterSwitchLeftAndRight</a></td><td class="desc">Switches the left and right channel </td></tr>
<tr id="row_0_25_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_converter_to_internal_d_a_c_format.html" target="_self">ConverterToInternalDACFormat</a></td><td class="desc">Special case for internal DAC output, the incomming PCM buffer needs to be converted from signed 16bit to unsigned </td></tr>
<tr id="row_0_26_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_csv_stream.html" target="_self">CsvStream</a></td><td class="desc"><a class="el" href="class_stream.html">Stream</a> Wrapper which can be used to print the values as readable ASCII to the screen to be analyzed in the Serial Plotter The frames are separated by a new line. The channels in one frame are separated by a , </td></tr>
<tr id="row_0_27_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_generated_sound_stream.html" target="_self">GeneratedSoundStream</a></td><td class="desc">Source for reading generated tones. Please note </td></tr>
<tr id="row_0_28_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_chunk_reader.html" target="_self">HttpChunkReader</a></td><td class="desc">Http might reply with chunks. So we need to dechunk the data. see <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">https://en.wikipedia.org/wiki/Chunked_transfer_encoding</a> </td></tr>
<tr id="row_0_29_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_header.html" target="_self">HttpHeader</a></td><td class="desc">In a http request and reply we need to process header information. With this API we can define and query the header information. The individual header lines are stored in a vector. This is the common functionality for the <a class="el" href="classaudio__tools_1_1_http_request.html" title="Simple API to process get, put, post, del http requests I tried to use Arduino HttpClient,...">HttpRequest</a> and <a class="el" href="classaudio__tools_1_1_http_reply_header.html" title="Reading and Writing of Http Replys.">HttpReplyHeader</a> subclasses </td></tr>
<tr id="row_0_30_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_http_header_line.html" target="_self">HttpHeaderLine</a></td><td class="desc">A individual key - value header line </td></tr>
<tr id="row_0_31_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_line_reader.html" target="_self">HttpLineReader</a></td><td class="desc">We read a single line. A terminating 0 is added to the string to make it compliant for c string functions </td></tr>
<tr id="row_0_32_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_reply_header.html" target="_self">HttpReplyHeader</a></td><td class="desc">Reading and Writing of Http Replys </td></tr>
<tr id="row_0_33_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_request.html" target="_self">HttpRequest</a></td><td class="desc">Simple API to process get, put, post, del http requests I tried to use Arduino HttpClient, but I did not manage to extract the mime type from streaming get requests </td></tr>
<tr id="row_0_34_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_http_request_header.html" target="_self">HttpRequestHeader</a></td><td class="desc">Reading and writing of Http Requests </td></tr>
<tr id="row_0_35_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_i2_s.html" target="_self">I2S</a></td><td class="desc">A Simple <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> interface class for the ESP32 which supports the reading and writing with a defined data type </td></tr>
<tr id="row_0_36_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_i2_s_base.html" target="_self">I2SBase</a></td><td class="desc">Basic <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> API - for the ESP32. If we receive 1 channel, we expand the result to 2 channels </td></tr>
<tr id="row_0_37_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_i2_s_config.html" target="_self">I2SConfig</a></td><td class="desc">Configuration for all common i2s settings </td></tr>
<tr id="row_0_38_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_i2_s_stream.html" target="_self">I2SStream</a></td><td class="desc">We support the <a class="el" href="class_stream.html">Stream</a> interface for the <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> access. In addition we allow a separate mute pin which might also be used to drive a LED.. </td></tr>
<tr id="row_0_39_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1int24__t.html" target="_self">int24_t</a></td><td class="desc">24bit integer which is used for <a class="el" href="classaudio__tools_1_1_i2_s.html" title="A Simple I2S interface class for the ESP32 which supports the reading and writing with a defined data...">I2S</a> sound processing. It works only on little endian machines! </td></tr>
<tr id="row_0_40_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_memory_stream.html" target="_self">MemoryStream</a></td><td class="desc">A simple <a class="el" href="class_stream.html">Stream</a> implementation which is backed by allocated memory </td></tr>
<tr id="row_0_41_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_mozzi_generator.html" target="_self">MozziGenerator</a></td><td class="desc">Support for <a href="https://sensorium.github.io/Mozzi/">https://sensorium.github.io/Mozzi/</a> Define your updateControl() method. Define your updateAudio() method. Start by calling begin(control_rate) do not call audioHook(); in the loop ! </td></tr>
<tr id="row_0_42_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_multi_converter.html" target="_self">MultiConverter</a></td><td class="desc">Combines multiple converters </td></tr>
<tr id="row_0_43_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_musical_notes.html" target="_self">MusicalNotes</a></td><td class="desc">Determination of the frequency of a music note </td></tr>
<tr id="row_0_44_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_n_buffer.html" target="_self">NBuffer</a></td><td class="desc">A lock free N buffer. If count=2 we create a DoubleBuffer, if count=3 a TripleBuffer etc </td></tr>
<tr id="row_0_45_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_noise_generator.html" target="_self">NoiseGenerator</a></td><td class="desc">Generates a Sound with the help of rand() function </td></tr>
<tr id="row_0_46_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_n_o_p_converter.html" target="_self">NOPConverter</a></td><td class="desc">Dummy converter which does nothing </td></tr>
<tr id="row_0_47_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_pico_channel_out.html" target="_self">PicoChannelOut</a></td><td class="desc">Rasperry Pico Channel to pin assignments </td></tr>
<tr id="row_0_48_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_p_i_n_info.html" target="_self">PINInfo</a></td><td class="desc">Information for a PIN </td></tr>
<tr id="row_0_49_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_p_w_m_audio_stream.html" target="_self">PWMAudioStream</a></td><td class="desc">Audio output to PWM pins for the ESP32. The ESP32 supports up to 16 channels </td></tr>
<tr id="row_0_50_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_p_w_m_config.html" target="_self">PWMConfig</a></td><td class="desc">Configuration for PWM output </td></tr>
<tr id="row_0_51_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_sine_wave_generator.html" target="_self">SineWaveGenerator</a></td><td class="desc">Generates a Sound with the help of sin() function </td></tr>
<tr id="row_0_52_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_single_buffer.html" target="_self">SingleBuffer</a></td><td class="desc">A simple Buffer implementation which just uses a (dynamically sized) array </td></tr>
<tr id="row_0_53_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_sound_generator.html" target="_self">SoundGenerator</a></td><td class="desc">Base class to define the abstract interface for the sound generating classes </td></tr>
<tr id="row_0_54_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_str.html" target="_self">Str</a></td><td class="desc">A simple wrapper to provide string functions on char*. If the underlying char* is a const we do not allow any updates; The ownership of the chr* must be managed externally! </td></tr>
<tr id="row_0_55_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_stream_copy.html" target="_self">StreamCopy</a></td><td class="desc">We provide the typeless <a class="el" href="classaudio__tools_1_1_stream_copy.html" title="We provide the typeless StreamCopy as a subclass of StreamCopyT.">StreamCopy</a> as a subclass of <a class="el" href="classaudio__tools_1_1_stream_copy_t.html" title="Typed Stream Copy which supports the conversion from channel to 2 channels. We make sure that we allw...">StreamCopyT</a> </td></tr>
<tr id="row_0_56_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_stream_copy_t.html" target="_self">StreamCopyT</a></td><td class="desc">Typed <a class="el" href="class_stream.html">Stream</a> Copy which supports the conversion from channel to 2 channels. We make sure that we allways copy full samples </td></tr>
<tr id="row_0_57_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_str_ext.html" target="_self">StrExt</a></td><td class="desc"><a class="el" href="classaudio__tools_1_1_str.html" title="A simple wrapper to provide string functions on char*. If the underlying char* is a const we do not a...">Str</a> which keeps the data on the heap. We grow the allocated memory only if the copy source is not fitting </td></tr>
<tr id="row_0_58_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_timer_alarm_repeating.html" target="_self">TimerAlarmRepeating</a></td><td class="desc">Repeating Timer functions for simple scheduling of repeated execution. The basic logic is taken from <a href="https://www.toptal.com/embedded/esp32-audio-sampling">https://www.toptal.com/embedded/esp32-audio-sampling</a> </td></tr>
<tr id="row_0_59_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_timer_callback.html" target="_self">TimerCallback</a></td><td class="desc">Internal class to manage the different timer callbacks for the 4 hardware timers </td></tr>
<tr id="row_0_60_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_url.html" target="_self">Url</a></td><td class="desc">URL parser which breaks a full url string up into its individual parts </td></tr>
<tr id="row_0_61_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_u_r_l_stream.html" target="_self">URLStream</a></td><td class="desc">Represents the content of a URL as <a class="el" href="class_stream.html">Stream</a>. We use the WiFi.h API </td></tr>
<tr id="row_0_62_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_user_callback.html" target="_self">UserCallback</a></td><td class="desc">Internal class to manage User callbacks. An optinal parameter can be passed to the callback method </td></tr>
<tr id="row_0_63_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_0_63_" class="arrow" onclick="toggleFolder('0_63_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_vector.html" target="_self">Vector</a></td><td class="desc"><a class="el" href="classaudio__tools_1_1_vector.html" title="Vector implementation which provides the most important methods as defined by std::vector....">Vector</a> implementation which provides the most important methods as defined by std::vector. This is neither part of Pico nor of the Arduino framwork but nevertheless it is quite handy to have and most of the times quite better then dealing with raw c arrays </td></tr>
<tr id="row_0_63_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_vector_1_1iterator.html" target="_self">iterator</a></td><td class="desc">Iterator for the <a class="el" href="classaudio__tools_1_1_vector.html" title="Vector implementation which provides the most important methods as defined by std::vector....">Vector</a> class </td></tr>
<tr id="row_0_64_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structaudio__tools_1_1_w_a_v_audio_info.html" target="_self">WAVAudioInfo</a></td><td class="desc">Sound information which is available in the WAV header </td></tr>
<tr id="row_0_65_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_w_a_v_decoder.html" target="_self">WAVDecoder</a></td><td class="desc"><a class="el" href="classaudio__tools_1_1_w_a_v_decoder.html" title="WAVDecoder - We parse the header data on the first record and send the sound data to the stream which...">WAVDecoder</a> - We parse the header data on the first record and send the sound data to the stream which was indicated in the constructor. Only WAV files with WAV_FORMAT_PCM are supported! </td></tr>
<tr id="row_0_66_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_w_a_v_encoder.html" target="_self">WAVEncoder</a></td><td class="desc">A simple WAV file encoder </td></tr>
<tr id="row_0_67_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classaudio__tools_1_1_w_a_v_header.html" target="_self">WAVHeader</a></td><td class="desc">Parser for Wav header data for details see <a href="https://de.wikipedia.org/wiki/RIFF_WAVE">https://de.wikipedia.org/wiki/RIFF_WAVE</a> </td></tr>
<tr id="row_1_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_print.html" target="_self">Print</a></td><td class="desc"></td></tr>
<tr id="row_2_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_printable.html" target="_self">Printable</a></td><td class="desc"></td></tr>
<tr id="row_3_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_3_" class="arrow" onclick="toggleFolder('3_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_stream.html" target="_self">Stream</a></td><td class="desc"></td></tr>
<tr id="row_3_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_stream_1_1_multi_target.html" target="_self">MultiTarget</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
